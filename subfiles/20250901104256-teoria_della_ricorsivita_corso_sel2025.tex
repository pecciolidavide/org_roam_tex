% Intended LaTeX compiler: pdflatex
\documentclass[../main]{subfiles}


\begin{document}

\section{Teoria della ricorsività [CORSO SEL2025]}
\label{sec:org38ca632}

\subsection{Lezione 1}
\label{sec:orgfb9c186}

La ``Teoria della ricorsività'' è stata rinominata ``Teoria della computabilità'' all'inizio degli anni '90.

\begin{definizione}
La Teoria della Computabilità è lo studio sistematico della \uline{complessità} dei probeli matematici.
\end{definizione}

Struttura del corso
\begin{enumerate}
\item Due modelli di computazione e la loro equivalenza.
\item Dalla tesi di Church-Turing alla complessità astratta degli insiemi.
\item Esplorando l'universo di Turing.
\item (Computable Structure Theory.)
\end{enumerate}
\subsubsection{Notazione}
\label{sec:org13a8b82}

\begin{itemize}
\item \(\omega\) denota l'insieme dei numeri naturali.
\item Con \(\oldvec{x}\) si denotano le \(k\)-uple di numeri naturali \((x_{1},\dots,x_{k})\)
\item Si consentono le funzioni parziali. Si scriverà \(f(x)\uparrow\) per scrivere che \(f\) non è definita su \(x\). Viceversa, \(f(x)\downarrow\) significa che \(f(x)=y\).
\end{itemize}
\subsubsection{Modelli di computazione}
\label{sec:orgdf6f83d}

Lo scopo di un modello di computazione è quello di catturare la classe delle funzioni computabili ``intuitivi''.
\subsubsection{Funzioni parziali ricorsive}
\label{sec:orga0431ec}

Si formalizza la computabilità dal basso verso l'alto:
\begin{itemize}
\item si inizia da alcune funzioni molto semplici che indiscutibilmente sono computabili;
\item si introducono degli operatori che permettono di costruire funzioni più complesse preservando la computabilità.
\end{itemize}

\begin{definizione}
Le funzioni di base sono:
\begin{itemize}
\item la costante \(0\) (una funzione 0-aria);
\item la funzione zero \(\operatorname{Zero}(x) = 0\) per ogni \(x\);
\item la funzione successore \(\operatorname{S}(x)\) che associa ad \(x\) il suo successore in \(\omega\);
\item le proiezioni \(P^{i}_{k}(x_{1},\dots,x_{k}) = x_{i}\) per ogni \(1\le i\le k\);
\end{itemize}
\end{definizione}

\begin{definizione}
Una funzione \(k\)-aria \(f(\oldvec{x})\) è ottenuta per \uline{composizione} da una funzione \(n\)-aria \(g(\oldvec{y})\) e \(n\) funzioni \(k\)-arie \(h_{1}(\oldvec{x}),\dots,h_{n}(\oldvec{x})\) se, per ogni tupla \(\oldvec{x}\):
\begin{equation*}
f(\oldvec{x}) = g\big(h_{1}(\oldvec{x}),\dots,h_{n}(\oldvec{x})\big).
\end{equation*}
\end{definizione}

\begin{definizione}
Una funzione \((k+1)\)-aria \(f(\oldvec{x},y)\) è ottenuta per \uline{ricorsione primitiva} da una funzione \(k\)-aria \(g(\oldvec{x})\) e una funzione\((k+2)\)-aria \(h(\oldvec{x},y,z)\) se per ogni tupla \((\oldvec{x},y)\):
\begin{equation*}
\begin{cases}
f(\oldvec{x},0) = g(\oldvec{x});\\
f(\oldvec{x},y+1) = h\big(\oldvec{x},y,f(\oldvec{x},y)\big).
\end{cases}
\end{equation*}
\end{definizione}

\begin{definizione}
Una funzione \(k\)-aria \(f\) è \uline{primitiva ricorsiva} se [\ldots{}]
\end{definizione}

Bisogna capire adesso se la classe delle funzioni primitive ricorsive è adatta a descrivere le funzioni intuitivamente computabili. Per farlo, si deve guardare che le funzioni che siamo certi essere computabili ne fanno parte.

\begin{prop}
Alcuni fatti:
\begin{itemize}
\item Tutti i numeri naturali (come funzioni 0-arie) sono primitivi ricorsivi.
\item Tutte le funzioni costanti a \(n\), per \(n \in \omega\), sono ricorsive primitive.
\item L'addizione \(f(x,y)=x+y\) è ricorsiva primitiva.
\item Moltiplicazione, elevamento a potenza e tetrazione sono primitive ricorsive.
\item Le \href{20250901153512-iperoperazioni.org}{iperoperazioni} sono ricorsive primitive.
\item La funzione segno (e il suo complemento) è ricorsiva primitiva:
\begin{equation*}
  \operatorname{sng}(x) = \begin{cases}
  0 & x=0\\
  1 & x>0.
  \end{cases}
\end{equation*}
\end{itemize}
\end{prop}

\begin{definizione}
Funzioni e relazioni primitive ricorsive.
\end{definizione}

\begin{prop}
Le relazioni ``\(\le\)'' e ``\(=\)'' sono ricorsive primitive.
\end{prop}

\begin{prop}
La classe delle relazioni primitive ricorsive sono chiuse per unione (congiunzione), intersezione (disgiunzione) e complementazione.
\end{prop}

\begin{prop}
Se \(f\) è una funzione definita a tratti da funzioni ricorsive primitive su relazioni ricorsive primitive, allora \(f\) è primitiva ricorsiva.
\end{prop}

\begin{prop}
Tutti gli insiemi finiti e cofiniti sono primitivi ricorsivi.
\end{prop}

\begin{prop}
Ogni funzione ricorsiva primitiva è totale.
\end{prop}

Quindi alcune funzioni ``naturali'' non sono ricorsive primitive. Esempio semplice è la sottrazione:
\begin{equation*}
f(x,y)=\begin{cases}
x-y, &x\ge y\\
\uparrow,&\text{altrimenti}.
\end{cases}
\end{equation*}

\begin{definizione}
Una funzione \(k\)-aria \(f(\oldvec{x})\) è ottenuta per \uline{minimizzazione} da una funzione \((k+1)\)-aria \(g(\oldvec{x},y)\) se
\begin{equation*}
f(\oldvec{x}) =\begin{cases}
y, &\text{se }g(\oldvec{x},y)=0\text{ e }\forall z<y\ \big(g(\oldvec{x},z)\downarrow\neq 0\big)\\
\uparrow,&\text{altrimenti}
\end{cases}
\end{equation*}
e si scrive
\begin{equation*}
f(\oldvec{x}) = \minim{z}{g(\oldvec{x},z) = 0}.
\end{equation*}
\end{definizione}

\begin{definizione}
Una funzione \(k\)-aria \(f(\oldvec{x})\) è \uline{ricorsiva parziale} se esiste una sequenza finita di funzioni \((f_{0},\dots,f_{m})\) tali che, per ogni \(i\le m\):
\begin{itemize}
\item \(f_{i}\) è una funzione di base, oppure è ottenuta [\ldots{}]
\end{itemize}
\end{definizione}

Ogni funzione primitiva ricorsiva è anche ricorsiva parziale. Il viceversa non vale (come mostra ogni funzione computabile non totale).

\begin{esempio}
La funzione di sottrazione è ricorsiva parziale:
\begin{equation*}
f(x,y)=\begin{cases}
x-y, &x\ge y\\
\uparrow,&\text{altrimenti}.
\end{cases}
\end{equation*}
\end{esempio}

Questo porta ad una tesi (a prima vista incredibile):
\begin{quote}
Ogni funzione intuitivamente computabile è parziale ricorsiva\qquad(\textbf{\textbf{T}})
\end{quote}
\subsection{Lezione 2}
\label{sec:org1965a62}

\subsubsection{Turing's computability}
\label{sec:org73e9cf8}

Le macchine di Turing possono essere descritte come: \emph{macchine che assomigliano agli esseri umani quando questi si comportano come macchine}.

Il modello di computazione è dato da due ingredienti:
\begin{itemize}
\item un \uline{nastro}, diviso in celle. Il nastro è discreto e infinito in entrambe le direzioni (order-isomorphic a \(\Z\));
\item una \uline{testina}, che ad ogni passo scansiona esattamente una cella e, in base allo \uline{stato}, può fare due azioni:
\begin{itemize}
\item muoversi a destra o a sinsitra di una cella;
\item scrivere un simbolo sulla cella scansionata.
\end{itemize}
\end{itemize}

Formalmente sono necessari tre componenti:
\begin{itemize}
\item un alfabeto finito \(\Sigma\) di \uline{simboli} (qui prendiamo \(\Sigma=\set{0,1}\));
\item un insieme finito \(Q=\set{q_{0},\dots,q_{n}}\) di \uline{stati};
\item un insieme di \uline{operazioni} \(O=\set{L,R}\cup \Sigma = \set{0,1,L,R}\), dove
\begin{itemize}
\item \(L\) ``la testina si muove a sinistra''
\item \(R\) ``la testina si muove a destra'';
\item per ogni \(\sigma \in \Sigma\), ``la testina scrive \(\sigma\) nella cella''.
\end{itemize}
\end{itemize}

Un \uline{istruzione} è una quadrupla \((q_{i}, s,0,q_{j}) \in Q\times \Sigma\times O\times Q\), interpretato come: se la testina è nello stato \(q_{i}\) e scansiona il simbolo \(s\), allora fà l'operazione \(o\) e va allo stato \(q_{j}\).

Un \uline{programma} è un insieme finito di istruzioni, con la convenzione che tutte abbiano le prime due coordinate diverse.

Una \uline{macchina di Turing} \(\bm{M}\) applica il programma ad un nastro, con queste regole:
\begin{enumerate}
\item \(\bm{M}\) inizia nello stato \(q_{0}\);
\item ad ogni passo scansiona esattamente una cella;
\item se \(\bm{M}\) è nello stato \(q_{i}\) scansionando \(s\), esegue l'unica istruzione che inizia per \((q_{i}, s)\), se esiste;
\item se nessuna istruzione si applica, \(\bm{M}\) \uline{halts}.
\end{enumerate}

Una \uline{configurazione} di \(\bm{M}\) è una tripla
\begin{equation*}
(\text{contenuto del nastro}, \text{ cellula scansionata}, \text{ stato})
\end{equation*}
e ogni istruzione può essere visto come una funzione trasformando una configurazione in un'altra.

\uline{NOTAZIONE}\ldots{}

\begin{prop}
Esiste una macchina di Turing che diverge (ovvero che non \uline{halts} mai) su ogni nastro di input.
\end{prop}

\begin{prop}
Esiste una macchina di Turing \(\bm{M}\) tale che
\begin{equation*}
0^{\infty} 1^{n} 0^{\infty}\quad\to_{\bm{M}}\quad 0^{\infty} 1^{2n} 0^{\infty}
\end{equation*}
\end{prop}

\begin{definizione}
Una funzione \(k\)-aria \(f(\oldvec{x})\) è Turing-computabile se esiste una macchina di Turing \(\bm{M}\) tale che
\begin{equation*}
0^{\infty}\, 1^{x_{1}+1}\,0\,1^{x_{2}+1}\,0 \dots 0\,1^{x_{k}+1}\,0^{\infty}\quad \longrightarrow_{\bm{M}}\quad 0^{\infty}\,1^{y}\,0^{\infty}
\end{equation*}
se e solose \(f(x_{1},\dots,x_{k})=y\).
\end{definizione}

\begin{prop}
La funzione \(\operatorname{S}(x) =x+1\) è Turing-computable
\end{prop}

Anche la funzione costante \(0\) è Turing-computable.

\begin{prop}
L'addizione è Turing-computable.
\end{prop}

Se una funzione è Turing-computable, ci sono molti modi per computarla.

\begin{prop}
Se una funzione \(f\) è Turing-computable, allora esistono infinite macchine di Turing distinte che computa \(f\).
\end{prop}

Scriveremo \(\bm{M}\approx\bm{M}'\) se \(\bm{M}\) e \(\bm{M}'\) computano la stessa funzione.

\begin{prop}
Le seguenti sono Turing-computable:
\begin{itemize}
\item tutte le proiezioni \(P^{i}_{k}(x_{1},\dots,x_{k})=x_{i}\);
\item ogni funzione costante
\item la relazione di uguaglianza (tramite funzione caratteristica)
\end{itemize}
\end{prop}

\begin{thm}
Una funzione \(f\) è Turing-computable sse \(f\) è ricorsiva parziale.
\end{thm}
\begin{lem}
Ogni funzione parziale ricorsiva è Turing-computable
\end{lem}
\begin{proof}
Tutte le funzioni di base sono Turing-computabili. Resta da dimostrare che gli operatori di composizione, ricorsione e minimizzazione possono essere simulati dalle macchine di Turing.
\begin{itemize}
\item \uline{Composizione}: si supponga \(f=g\circ h\), con \(g\) e \(h\) sono Turing-computable dalle macchine \(\bm{T}_{g}\), \(\bm{T}_{h}\). L'idea è quella di costruire \(\bm{T}_{f}\) eseguendo \(\bm{T}_{h}\) e poi \(\bm{T}_{g}\). Ci sono due problemi:
\begin{itemize}
\item c'è una differenza nel modo in cui sono codificati gli input rispetto agli output; \emph{easy fix} con una subroutine \(\bm{T}_{\text{out}\to\text{inp}}\);
\item collisione degli stati: sia \(\bm{T}_{h}\) e \(\bm{T}_{g}\) hanno stati chiamati \(q_{0},q_{1},\dots\); \emph{shiftare} gli stati non è sufficiente, in quanto può darsi che la macchina di Turing \(\bm{T}_{h}\) non termini nel suo stato dal numero più alto; è sufficiente ``aggiungere'' lo stato di arresto della macchina \(\bm{T}_{h}\). AGGIUNGERE DALLE NOTE I DETTAGLI.
\end{itemize}
\item \uline{Minimizzazione} e \uline{ricorsione}: ci fidiamo.\qedhere
\end{itemize}
\end{proof}
\begin{lem}
Ogni funzione Turing-computable è parziale ricorsiva
\end{lem}
\begin{proof}
L'idea base è che si può considerare ciascuna componente di una macchina di Turing come un numero naturale, e poi vedere l'intera computazione come un predicato aritmetico.

Si costruirà una funzione di codifica \(\gamma\) per induzione.

Sia \(o\) un operazione della macchina di Turing:
\begin{equation*}
\gamma(o) = \begin{cases}
1, &o=0,\\
2, &o=1,\\
3, &o=L,\\
4, &o=R.
\end{cases}
\end{equation*}

\uline{SLIDE 61, 62, 63, 64, 65, 66, 67}
\end{proof}

\begin{oss}
Questa dimostrazione ci ha fornito la \href{20250601162102-teorema_di_forma_normale_di_kleene.org}{Forma Normale di Kleene}.
\end{oss}

La classe delle funzioni computabili è ottenibile in molti altri modelli computazionali:
\begin{itemize}
\item macchine di Turing modificate
\item \(\lambda\)-calcolo
\item macchine a registri
\item diagrammi di flussi
\item Java, Python, C
\end{itemize}
\subsubsection{Tesi di Church-Turing}
\label{sec:orgb80cfa2}

La classe delle funzioni intuitivamente computabile coincide con la classe delle funzioni computabili in ciascuno dei modelli (equivalenti) di computazione. \hfill (\textbf{\textbf{CTT}})
\subsection{Lezione 3}
\label{sec:org9c2b09d}

\subsubsection{Conseguenze di CTT}
\label{sec:orgb198355}

\begin{oss}
Esiste una funzione iniettiva \(\gamma\) che assenga a ciascuna macchina di Turing un codice \(e \in \omega\), con codifica e decodifica ricorsive primitive. In più, \(\gamma\) può essere scelta per essere una biiezione.
\end{oss}

\begin{thm}
Esiste una enumerazione computabile \((\varphi_{e})_{e \in \omega}\) di tutte le funzioni computabili.
\end{thm}

D'ora in avanti \(\varphi_{e}\) è la funzione computabile dalla macchina di Turing con codice \(e\).
\begin{thm}
Esiste una funzione computabile binaria \(h\) tale che, per ogni \(e\) e \(x\):
\begin{equation*}
h(e,x)=\varphi_{e}(x).
\end{equation*}
\end{thm}
\begin{proof}
Ponendo
\begin{equation*}
h(e,x)\coloneqq U\big(\minim{y}{T(e,x,y)}\big)\qedhere
\end{equation*}
\end{proof}

Una funzione come \(h\) si dice \uline{funzione universale} o \uline{macchina universale}. Il teorema afferma che \emph{i computer esistono}.

\begin{thm}
Esisono funzioni \(f:\omega\to\omega\) che non sono computabili
\end{thm}
\begin{proof}
Il risultato segue banalmente da ragioni di cardinalità. Si dà, per diagonalizzazione, una funzione esplicitamente non computabile:
\begin{equation*}
f(x)=\begin{cases}
\varphi_{x}(x)+1, & \text{se }\varphi_{x}(x)\downarrow\\
0,&\text{altrimenti}.
\end{cases}\qedhere
\end{equation*}
\end{proof}

Il teorema fornisce una ``risposta'' all'\uline{halting problem}, un problema posto da Hilbert e Ackermann nel 1928:
\begin{quote}
Dato un programma \(P\) e un input \(x\), \(P\) halt su \(x\) o andrà avanti all'infinito?
\end{quote}
che risulta essere indecidibile (altrimenti \(f\) come definita prima sarebbe computabile).

Provando ad utilizzare nuovamente la diagonalizzazione, si definisca
\begin{equation*}
\psi(x)=\begin{cases}
\varphi_{x}(x)+1, & \text{se }\varphi_{x}(x)\downarrow\\
\uparrow,&\text{altrimenti}.
\end{cases}
\end{equation*}
che \uline{è computabile}. Qui la diagonalizzazione ``fallisce'', poiché \(\varphi_{x}(x) \cong\psi(x)\) ogni qualvolta che \(\varphi_{x}(x)\uparrow\), e peranto la parzialità delle funzioni computabili è una ``difesa'' contro la diagonalizzazione.
\subsubsection{Teorema di Punto fisso di Kleene}
\label{sec:org2ef168a}

\begin{thm}
(Teorema di Punto fisso di Kleene)\hspace{1em} Per ogni funzione computabile \(f\) esiste un indice \(e\) tale che \(e\) e \(f(e)\) computano la stessa funzione:
\begin{equation*}
\varphi_{e}\cong\varphi_{f(e)}.
\end{equation*}
\label{thm:kleenfpt}
\end{thm}
\paragraph{Conseguenze del Teorema}
\label{sec:org1290f7a}

\begin{oss}
Siccome per ogni funzione computabile ci sono infiniti progrmmi che lo computano, questo dà luogo ad un problema:
\begin{quote}
Dati due programmi \(P_{1}\) e \(P_{2}\), decidere se computano la stessa funzione.
\end{quote}
\end{oss}

Il prossimo risultato ci dirà che questo è un problema impossibile.

\begin{thm}
(Rice)\hspace{0.7em} Sia \(\mathcal{I}\) una famiglia di funzioni computabili t.c. \(\mathcal{I}\neq\emptyset\) e \(\mathcal{I}\) non è l'intero insieme delle funzioni computabili.

Allora \(A=\set{e\mid \varphi_{e} \in I}\) non è computabile.
\end{thm}
\begin{proof}
Se per assurdo \(A\) è computabile, siano \(a,b\) tale che
\begin{equation*}
\varphi_{a} \in \mathcal{I},\quad \varphi_{b}\notin\mathcal{I}.
\end{equation*}
Si definisca la funzione computabile
\begin{equation*}
f(x)=\begin{cases}
b,&\text{if } x\in A\\
a, &\text{if }x \notin A.
\end{cases}
\end{equation*}
Per il teorema di punto fisso, esiste \(n\) tale che \(\varphi_{n}=\varphi_{f(n)}\). Dunque
\begin{equation*}
\varphi_{n} \in \mathcal{I}\iff \varphi_{f(n)} \in \mathcal{I}\iff f(n)=a \iff n\notin A\iff \varphi_{n} \notin \mathcal{I}.\qedhere
\end{equation*}
\end{proof}

Tramite questo teorema è possibile dimostra che i seguenti insiemi sono non computabili:
\begin{itemize}
\item \(\mathrm{Tot}\coloneqq\set{e \mid\varphi_{e}\text{ è totale}}\);
\item \(\mathrm{Fin}\coloneqq\set{e \mid\operatorname{dom}(\varphi_{e})\text{ è finito}}\)
\item \(\set{e\mid \varphi_{e}\cong f}\)
\end{itemize}

\begin{thm}
(Teorema dei Parametri di Kleene)\hspace{0.8em} Esiste una funzione iniettiva computabile \(s:\omega\times\omega\to \omega\) tale che
\begin{equation*}
\varphi_{s(e,x)}(y) = \varphi_{e}(x,y)\quad\text{ per ogni }e,x,y.
\end{equation*}
\end{thm}

\begin{definizione}
Una \emph{quine} è un programma che come output ha il suo stesso codice sorgente.
\end{definizione}

\begin{thm}
Le quine esistono, ovvero esiste una funzione computabile totale \(\varphi_{e}\) tale che, per ogni input, \(\varphi_{e}\) ha come output \(e\).
\end{thm}

\begin{proof}
Sia \(f(x,y)=x\). Questa funzione è computabile, e quindi \(f=\varphi_{m}\). Per il teorema dei parametri
\begin{equation*}
\varphi_{m}(x,y) = \varphi_{s(m,x)}(y).
\end{equation*}
Applicando il teorema di punto fisso: esiste \(e\) con
\begin{equation*}
\varphi_{e}(y) = \varphi_{s(m,e)}(y) = f(e,y)=e.
\end{equation*}
per ogni \(y\).
\end{proof}
\paragraph{Dimostrazione del Teorema di Punto Fisso}
\label{sec:org0f977a5}

\begin{proof}
(del Teorema~\ref{thm:kleenfpt})\hspace{0.7em} Si definisca
\begin{equation*}
g(x,y)=\begin{cases}
\varphi_{f(\varphi_{x}(x))}(y), &\text{se }\varphi_{x}(x)\downarrow\\
\uparrow,&\text{altrimenti}.
\end{cases}
\end{equation*}
Poiché \(g\) è computabile, esiste \(e\) tale che
\begin{equation*}
\varphi_{e}(x,y) = g(x,y)
\end{equation*}
e, per il Teorema dei Parametri, esiste \(s\) computabile tale che
\begin{equation*}
\varphi_{s(e,x)}(y) = g(x,y)=\begin{cases}
\varphi_{f(\varphi_{x}(x))}(y), &\text{se }\varphi_{x}(x)\downarrow\\
\uparrow,&\text{altrimenti}.
\end{cases}
\end{equation*}
Inoltre, fissato \(e\), la funzione \(t(x)=s(e,x)\) è computabile e totale, e pertanto vi è \(m\) tale che
\begin{equation*}
\varphi_{\varphi_{m}}(y)=g(x,y)=\begin{cases}
\varphi_{f(\varphi_{x}(x))}(y), &\text{se }\varphi_{x}(x)\downarrow\\
\uparrow,&\text{altrimenti}.
\end{cases}
\end{equation*}
Dunque \(\varphi_{m}\) converge ovunque, ed in particolare \(\varphi_{m}(m)\downarrow\) e dunque per ogni \(y\):
\begin{equation*}
\varphi_{\varphi_{m}(m)}(y) = \varphi_{f(\varphi_{m}(m))}(y).\qedhere
\end{equation*}
\end{proof}
\subsubsection{Indecidibilità}
\label{sec:orga618701}

L'indecidibilità non è semplicemente legato alla logica. Alcuni famosi esempi:
\begin{itemize}
\item il problema della parola per gruppi finitamente generati;
\item decidere se una equazione diofantea ha soluzioni;
\item generalizzazione della congettura di Collatz;
\item determinare se un livello di \emph{Super Mario} è risolvibile.
\end{itemize}

La maggior parte delle prove di indecidibilità procedono riducendo il problema all'halting problem.
\paragraph{Busy Beaver}
\label{sec:org429bf78}

Dato un numero fissato di stati, qual è il massimo numero di passi che una macchina di Turing può fare prima di fermarsi?

Formalmente, la funzione \emph{busy beaver} \(\mathrm{BB}(n)\) è definita in maniera tale che: ogni macchina di Turing a \(n\)-stati che esegue per più di \(\mathrm{BB}(n)\) passi non si fermerà mai.

\begin{thm}
La funzione \(\mathrm{BB}\) non è computabile.
\end{thm}
\begin{proof}
Se lo fosse, si potrebbe risolvere l'halting problem.
\end{proof}

\begin{esempio}
Si consideri la \uline{Congettura di Goldbach} (GC). Esiste una macchina di Turing \(\bm{T}\) con 27 stati che elenca, uno alla volta, tutti i numeri pari esprimibili come somma di due primi. Pertanto \(\bm{T}\) si ferma sse la congettura di Goldbach è falsa.

Questo implica che:
\begin{itemize}
\item se GC è falsa, allora \(\mathrm{BB}(27)\) è estremo superiore del più grande controesempio.
\end{itemize}

Il problema è che \(\mathrm{BB}\) cresce più di ogni funzione computabile. Alcuni risultati recenti:
\begin{itemize}
\item \(\mathrm{BB}(5)=47\, 176\, 870\).
\item Il miglior lower bount di \(\mathrm{BB}(6)\) è
\begin{equation*}
  {^{^{^{9} 2} 2} 2}
\end{equation*}
\end{itemize}

In particolare, \(\mathrm{BB}\) cresce così velocemente che ZFC non può determinare praticamente nessun suo valore.
\end{esempio}
\subsubsection{Computable enumeration}
\label{sec:orga2dfb1a}

L'indecidibilità non è la fine della storia. Si sono sviluppate delle \uline{gerarchie} dell'impossibilità.

Si considerino i seguenti insiemi
\begin{align*}
S_{0} &\coloneqq \set{x \in \N\mid \pi\text{ ha un blocco di almeno }x\text{ consecutivi 7 nella sua espansione decimale}}\\
S_{1} &\coloneqq \set{x \in \N\mid \pi\text{ ha un blocco di esattamente }x\text{ consecutivi 7 nella sua espansione decimale}}
\end{align*}
\(S_{0}\) è computabile: è finito, oppure è tutto \(\N\) (e non importa che non lo sappiamo ancora).

Per \(S_{1}\), invece, non esiste (ancora) un algoritmo in grado di trovare patterne nell'espansione decimale di \(\pi\). Viceversa, però, esiste un modo per capire se un numero è in \(S_{1}\).

\begin{definizione}
Un insieme \(A \subseteq \N\) è computabilmente enumerabile (c.e.) se esiste una funzione computabile \(f\) tale che \(A=\operatorname{rng}(f)\).
\end{definizione}

\begin{prop}
L'insieme dei teoremi dell'Aritmetica di Peano è c.e.
\end{prop}

Esiste ovviamente un modo per enumerare computabilmente tutti i c.e.:
\begin{equation*}
W_{e}\coloneqq\operatorname{rng}(\varphi_{e}).
\end{equation*}

\begin{thm}
(Teorema di Post)\hspace{0.7em} Un insieme \(P\) è computabile se e solo se \(P\) e \(\N\setminus P\) sono c.e.
\end{thm}

\begin{prop}
Un insieme infinito \(A\) è computabile sse è il range di una funzione computabile strettamente crescente.
\end{prop}

\begin{prop}
Se \(A,B\) sono c.e., allora anche \(A\cup B, A\cap B\) sono c.e.
\end{prop}

\begin{prop}
Gli insiemi c.e. non sono chiusi per complemento.
\end{prop}
\subsection{Lezione 4}
\label{sec:org0c61adb}

\begin{prop}
Un insieme \(A\) è c.e. se e solose esiste una funzione computabile parziale \(g\) tale che \(A=\operatorname{dom}(g)\).
\end{prop}

\begin{definizione}
Si definisce l'\uline{insieme di arresto} \(K\):
\begin{equation*}
K\coloneqq\set{e\mid \varphi_{e}(e)\downarrow} = \set{e\mid e \in W_{e}}
\end{equation*}
\end{definizione}
\begin{thm}
\(K\) è un insieme c.e. non computabile.
\end{thm}
\begin{proof}
\(K\) è chiaramente c.e., in quanto ogni volta che \(\varphi_{i}(i)\) converge, si inserisce \(i\) in \(K\).

Per assurdo, si supponga \(K\) computabile. Allora \(\overline{K}\) è c.e., e pertanto \(\overline{K} = W_{e}\). Ma allora
\begin{equation*}
e \in \overline{K}\iff e \in W_{w} \iff e \in K
\end{equation*}
Assurdo.
\end{proof}
\subsubsection{Riducibilità \emph{many-one}.}
\label{sec:org7ab1248}

\begin{definizione}
Siano \(A, B \subseteq \N\). \(A\) è \uline{many-one riducibile} (o \(m\)-riducibile) a \(B\) (e si scrive \(A\mathrel{\le_{m}}B\)) se esiste una funzione computabile totale \(f\) tale che
\begin{equation*}
x \in A\quad\iff\quad f(x) \in B.
\end{equation*}
Se \(A\mathrel{\le_{m}}B\) e \(B\mathrel{\le_{m}} A\), allora \(A\) e \(B\) sono \(m\)-equivalenti, e si scrive \(A\mathrel{\equiv_{m}}B\).
\end{definizione}

\begin{oss}
È immediato verificare che \(\mathrel{\le_{m}}\) è diflessiva e transitiva, e quindi \(\equiv_{m}\) è una relazione di equivalenza.
\end{oss}

\begin{definizione}
Le classi di equivalenza sotto la \(m\)-equivalenza sono chiamati \uline{\(m\)-gradi}: per ogni \(A \subseteq \omega\), si scrive
\begin{equation*}
\bm{a}_{m}\coloneqq \operatorname{deg}_{m}(A) \coloneqq \set{X \subseteq \omega\mid X\mathrel{\equiv_{m}}A}.
\end{equation*}
Si scrive \((\bm{D}_{m},\le_{m})\) per la struttura degli \(m\)-gradi ordinati dalla \(m\)-riducibilità.
\end{definizione}

Intuitivamente, ogni grado è la collezione di tutti gli insiemi che hanno la stessa complessità computazionale (modulo la \(m\)-riduzione).
\begin{definizione}
Un \(m\)-grado \(\bm{d}_{m}\) è chiamato \uline{c.e.} se contiene un insieme c.e.; è \uline{computabile} se contiene un insieme computabile.
\end{definizione}

\begin{prop}
Esiste un \(m\)-grado minimo, che consiste esattamente di tutti gli insiemi computabili (tranne \(\emptyset\) e \(\omega\)); questo si denota con \(\bm{0}_{m}\).
\end{prop}

Si scrive invece \(\bm{0}_{m}'\) per il \(m\)-grado che contiene \(K\) (insieme di arresto).

Tramite argomenti di cardinalità, non può esistere un \(m\)-grado massimo.

\begin{definizione}
Un insieme \(A\) è \(m\)-completo se è c.e. e ogni insieme c.e. si \(m\)-riduce ad \(A\).
\end{definizione}

Tali insiemi esistono:
\begin{prop}
\(K\) è \(m\)-completo.
\end{prop}
\begin{proof}
Sia \(A\) un insieme c.e. arbitrario. La funzione
\begin{equation*}
f(x,y) =\begin{cases}
1, &x \in A\\
\uparrow, &\text{altrimenti};
\end{cases}
\end{equation*}
è ricorsiva.

Per il Teorema dei parametri esiste \(g\) computabile tale che
\begin{equation*}
\varphi_{g(x)}(y)\begin{cases}
1, &x \in A\\
\uparrow, &\text{altrimenti}.
\end{cases}
\end{equation*}
Se \(x \in A\), allora \(\varphi_{g(x)}\big(g(x)\big)\downarrow\), e pertanto \(g(x) \in K\). Se \(x\notin A\), allora \(\varphi_{g(x)}\big(g(x)\big)\uparrow\), e dunque \(g(x)\notin K\).

Pertanto \(A\mathrel{\le_{m}}K\), come richiesto.
\end{proof}

Il \uline{problema di Post} è il seguente: si è dimostrato che \(\bm{0}_{m}<\bm{0}_{m}'\); esiste qualcosa in mezzo?
\begin{definizione}
Un insieme c.e. \(A\) è detto \uline{creativo} se esiste una funzione computabile (chiamata la \uline{funzione creativa di \(A\)}) tale che
\begin{equation*}
W_{e} \subseteq \overline{A}\quad \implies\quad f(e) \in \overline{A}\setminus W_{e}.
\end{equation*}
\end{definizione}

In altre parole, quando un indice \(e\) descrive un insieme c.e. completamente contenuto in \(\overline{A}\), la funzione \(f\) può effettivamente produrre un testimone in \(\overline{A}\) che non è catturato da \(W_{e}\).

\begin{oss}
\(K\) è un insieme creativo, la sua funzione creativa è l'identità.
\end{oss}

\begin{thm}
Siano \(C,A\) degli insiemi c.e. tali che  \(C\mathrel{\le_{m}}A\). Allora \(C\) è creativo se e solo se \(A\) è creativo.
\end{thm}
\begin{cor}
Ogni insieme \(m\)-completo è creativo.
\end{cor}

\begin{definizione}
Insiemi che non contengono nessun insieme c.e. infinito sono chiamati \uline{immuni}.
\end{definizione}
Intuitivamente, gli insiemi immuni nascondono la loro informazione talmente bene che solo una porzione trascurabile del loro complemento puà essere catturata da un algoritmo.

\begin{definizione}
Un insieme \(S \subseteq \N\) si dice \uline{semplice} se
\begin{itemize}
\item \(S\) incontra ogni insieme c.e. infinito (ovvero se \(W_{e}\) è infinito allora \(S\cap W_{e}\neq \emptyset\));
\item \(S\) è co-infinito (ovvero \(\N \subseteq S\) è infinito).
\end{itemize}
\end{definizione}

\begin{prop}
Il complemento di ogni insieme semplice è immune, quindi gli insiemi semplici non possono essere creativi. Inoltre gli insiemi semplici non possono essere computabili.
\end{prop}

\begin{thm}
Esiste un insieme semplice. Pertanto, esiste un grado \(\bm{d}_{m}\) tale che
\begin{equation*}
\bm{0}_{m}<\bm{d}_{m}<\bm{0}_{m}'.
\end{equation*}
\end{thm}
\begin{proof}
Si vuole costruire un insieme semplice \(S\), che per ogni \(e \in \omega\) soddisfi:
\begin{description}
\item[{\(\mathcal{P}_{e}\):}] se \(W_{e}\) è infinito, allora \(S\cap W_{e}\neq \emptyset\);
\item[{\(\mathcal{N}_{e}\):}] al massimo \(e\) elementi di \(S\) sono minori di \(2e\).
\end{description}
Se tutti questi requisiti sono soddisfatti, allora \(S\) è semplice.

Si costruisce \(S\) ricorsivamente:
\begin{itemize}
\item Passo 0: Sia \(S = \emptyset\);
\item Passo \(s+1 = \bm{J}(e,t)\)\footnote{\(\bm{J}\) è una qualsiasi biiezione primitiva ricorsiva \href{20250215151413-biiezione_canonica_tra_n_e_n2.org}{\(\bm{J}:\omega^{2}\to\omega\)}, con inverse ricorsive primitive.}: se \(\mathcal{P}_{e}\) è ancora insoddifatto, si cerchi per qualche \(z>2e\), con \(z\) enumerato in \(W_{e}\) in meno di \(t\) passi.
\begin{itemize}
\item Se tale \(z\) esiste, se numeri \(z\) in \(S\) e dichiara \(\mathcal{P}_{e}\) soddisfatto.
\item Altrimenti, non fare nulla e procedi al passo successivo.
\end{itemize}
\end{itemize}

Resta da verificare che:
\begin{itemize}
\item ogni \(W_{e}\) infinito contribuisce ad \(S\) (quindi \(\mathcal{P}_{e}\) è soddisfatto);
\item la condizione \(\mathcal{N}_{e}\) è preservata.\qedhere
\end{itemize}
\end{proof}
\subsubsection{Teorema di Godel}
\label{sec:org8cfd9bf}

Il linguaggio dell'aritmetica è sufficientemente ricco per rappresentare la computabilità. In particolare, esiste una formula \(\varphi^{K}(x)\) tale che
\begin{equation*}
\N\vDash \varphi^{K}(n)\quad\iff\quad n \in K.
\end{equation*}

\begin{thm}
L'insieme \(\operatorname{Th}(\N)\) è produttivo (quando si identificano le formule con i loro codici).
\end{thm}

Un corollario di questo è il thm di Godel. (VEDI SLIDE)
\end{document}
